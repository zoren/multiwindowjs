<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <style>
      html,
      body {
        overflow: hidden;
        margin: 0;
        color: white;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" style="z-index: -1; position: absolute"></canvas>
    <h1>Multi window BroadcastChannel demo</h1>
    <script>
      // https://mdn.github.io/dom-examples/screenleft-screentop/
      const canvas = document.getElementById("canvas");

      const ctx = canvas.getContext("2d", { alpha: false });

      const sessionId = Math.random().toString(36).substr(2, 5);
      document.title = sessionId;

      const sessionObj = { sessionId };
      const sessionMap = new Map([[sessionId, sessionObj]]);

      const channel = new BroadcastChannel("position-channel");

      const drawLines = () => {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.translate(-window.screenLeft, -window.screenTop);

        const calcCenter = ({
          innerWidth,
          innerHeight,
          screenLeft,
          screenTop,
        }) => [screenLeft + innerWidth / 2, screenTop + innerHeight / 2];

        const centers = [...sessionMap.values()].map(calcCenter);
        ctx.beginPath();
        for (let i = 0; i < centers.length; i++) {
          const ci = centers[i];
          for (let j = i + 1; j < centers.length; j++) {
            ctx.moveTo(...ci);
            ctx.lineTo(...centers[j]);
          }
        }
        ctx.closePath();
        ctx.strokeStyle = "white";
        ctx.stroke();

        for (const [x, y] of centers) {
          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, 2 * Math.PI);
          ctx.fill();
        }
      };

      const postPosition = () =>
        setTimeout(() => channel.postMessage(sessionObj));

      // Get the DPR and size of the canvas
      const dpr = window.devicePixelRatio;
      const resizeWindow = () => {
        // Set the "actual" size of the canvas
        canvas.width = innerWidth * dpr;
        canvas.height = innerHeight * dpr;

        // Set the "drawn" size of the canvas
        canvas.style.width = `${innerWidth}px`;
        canvas.style.height = `${innerHeight}px`;

        sessionObj.innerWidth = innerWidth;
        sessionObj.innerHeight = innerHeight;
        // Scale the context to ensure correct drawing operations
        ctx.scale(dpr, dpr);

        drawLines();
        postPosition();
      };

      window.addEventListener("resize", resizeWindow);
      resizeWindow();

      const positionElem = () => {
        if (
          sessionObj.screenLeft === screenLeft &&
          sessionObj.screenTop === screenTop
        ) {
          window.requestAnimationFrame(positionElem);
          return;
        }
        sessionObj.screenLeft = screenLeft;
        sessionObj.screenTop = screenTop;

        drawLines();

        postPosition();
        window.requestAnimationFrame(positionElem);
      };

      window.requestAnimationFrame(positionElem);

      window.addEventListener("beforeunload", () => {
        channel.postMessage({ sessionId, message: "leaving" });
        channel.close();
      });

      channel.addEventListener("message", ({ data }) => {
        const { sessionId } = data;
        if (data.message === "leaving") {
          sessionMap.delete(sessionId);
        } else {
          const sess = sessionMap.get(sessionId);
          if (sess) Object.assign(sess, data);
          else {
            // when a new session is created, we broadcast our data
            postPosition();
            sessionMap.set(sessionId, data);
          }
          drawLines();
        }
      });
    </script>
  </body>
</html>
