<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Home</title>
    <style>
      html,
      body {
        overflow: hidden;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" style="z-index: -1; position: absolute"></canvas>
    <h1>Multi window broadcast channel demo</h1>
    <div id="sessions">
      <h2>Sessions</h2>
      <ul id="sessionList"></ul>
    </div>
    <script>
      const canvas = document.getElementById("canvas");
      let centerX = 0;
      let centerY = 0;
      const radius = 10;

      const ctx = canvas.getContext("2d", { alpha: false });

      const drawCenter = (x, y) => {
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
      };

      const drawBackground = () => {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      };

      const sessionList = document.getElementById("sessionList");
      const createSessionLi = (sessionId) => {
        const li = document.createElement("li");
        li.id = sessionId;
        const idSpan = document.createElement("span");
        idSpan.textContent = sessionId;
        li.append(
          idSpan,
          ": ",
          document.createElement("span"),
          ",",
          document.createElement("span")
        );
        return li;
      };
      const updateSessionElement = (li, { screenLeft, screenTop }) => {
        const [, l, t] = li.children;
        l.textContent = screenLeft;
        t.textContent = screenTop;
      };
      const sessionMap = new Map();
      const insertOrdered = (li) => {
        for (const child of sessionList.children) {
          if (li.id < child.id) {
            sessionList.insertBefore(li, child);
            return;
          }
        }
        sessionList.append(li);
      };

      const sessionId = Math.random().toString(36).substr(2, 5);

      const myli = createSessionLi(sessionId);
      myli.style.backgroundColor = "lightgreen";
      sessionList.append(myli);

      const channel = new BroadcastChannel("position-channel");

      const drawLines = () => {
        drawBackground();
        ctx.strokeStyle = "black";

        const sessions = [...sessionMap.values()];
        for (const o of sessions) {
          for (const p of sessions) {
            if (o === p) continue;
            ctx.beginPath();
            ctx.moveTo(
              o.centerScreenX - screenLeft,
              o.centerScreenY - screenTop
            );
            ctx.lineTo(
              p.centerScreenX - screenLeft,
              p.centerScreenY - screenTop
            );
            ctx.stroke();
          }
        }
        for (const o of sessions) {
          drawCenter(o.centerScreenX - screenLeft, o.centerScreenY - screenTop);
        }
        ctx.fillStyle = "green";
        ctx.beginPath();
        ctx.arc(centerX, centerY, 15, 0, 2 * Math.PI);
        ctx.fill();
      };

      const resizeWindow = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        centerX = canvas.width / 2;
        centerY = canvas.height / 2;

        drawLines();
      };

      window.addEventListener("resize", resizeWindow);
      resizeWindow();

      const o = {
        sessionId,
      };
      sessionMap.set(sessionId, o);
      const positionElem = () => {
        const { screenLeft, screenTop } = window;
        drawLines();
        const centerScreenX = screenLeft + centerX;
        const centerScreenY = screenTop + centerY;

        o.screenLeft = screenLeft;
        o.screenTop = screenTop;
        o.centerScreenX = centerScreenX;
        o.centerScreenY = centerScreenY;

        updateSessionElement(myli, o);
        channel.postMessage(o);
        window.requestAnimationFrame(positionElem);
      };

      window.requestAnimationFrame(positionElem);

      window.addEventListener("beforeunload", () => {
        channel.postMessage({ sessionId, message: "leaving" });
        channel.close();
      });

      channel.addEventListener("message", ({ data }) => {
        const { sessionId } = data;
        let sessionElement = document.getElementById(sessionId);
        if (data.message === "leaving") {
          sessionMap.delete(sessionId);
          if (sessionElement) sessionElement.remove();
        } else {
          sessionMap.set(sessionId, data);
          drawLines();
          if (!sessionElement) {
            sessionElement = createSessionLi(sessionId);
            insertOrdered(sessionElement);
          }
          updateSessionElement(sessionElement, data);
        }
      });
    </script>
  </body>
</html>
