<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <style>
      html,
      body {
        overflow: hidden;
        margin: 0;
        color: white;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" style="z-index: -1; position: absolute"></canvas>
    <h1>Multi window broadcast channel demo</h1>
    <div id="sessions">
      <h2>Sessions</h2>
      <ul id="sessionList"></ul>
    </div>
    <script>
      const canvas = document.getElementById("canvas");

      const ctx = canvas.getContext("2d", { alpha: false });

      const drawBackground = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      };

      const sessionList = document.getElementById("sessionList");
      const createSessionLi = (sessionId) => {
        const li = document.createElement("li");
        li.id = sessionId;
        const idSpan = document.createElement("span");
        idSpan.textContent = sessionId;
        li.append(
          idSpan,
          ": ",
          document.createElement("span"),
          ",",
          document.createElement("span")
        );
        return li;
      };
      const updateSessionElement = (
        li,
        { screenLeft, screenTop, innerWidth, innerHeight }
      ) => {
        const [, l, t] = li.children;
        l.textContent = JSON.stringify([screenLeft, screenTop]);
        t.textContent = JSON.stringify([innerWidth, innerHeight]);
      };
      const insertOrdered = (li) => {
        for (const child of sessionList.children) {
          if (li.id < child.id) {
            sessionList.insertBefore(li, child);
            return;
          }
        }
        sessionList.append(li);
      };

      const sessionId = Math.random().toString(36).substr(2, 5);
      document.title = sessionId;

      const sessionObj = { sessionId };
      const sessionMap = new Map([[sessionId, sessionObj]]);

      const myli = createSessionLi(sessionId);
      myli.style.fontWeight = "bold";
      sessionList.append(myli);

      const channel = new BroadcastChannel("position-channel");

      const calcCenter = ({
        innerWidth,
        innerHeight,
        screenLeft,
        screenTop,
      }) => [
        screenLeft + innerWidth / 2 - window.screenLeft,
        screenTop + innerHeight / 2 - window.screenTop,
      ];

      const drawLines = () => {
        drawBackground();

        const centers = [...sessionMap.values()].map(calcCenter);
        ctx.beginPath();
        for (let i = 0; i < centers.length; i++) {
          const ci = centers[i];
          for (let j = i + 1; j < centers.length; j++) {
            ctx.moveTo(...ci);
            ctx.lineTo(...centers[j]);
          }
        }
        ctx.closePath();
        ctx.strokeStyle = "white";
        ctx.stroke();

        for (const [x, y] of centers) {
          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, 2 * Math.PI);
          ctx.fill();
        }
      };

      const postPosition = () =>
        setTimeout(() => {
          channel.postMessage(sessionObj);
        });

      // Get the DPR and size of the canvas
      const dpr = window.devicePixelRatio;
      const resizeWindow = () => {
        // Set the "actual" size of the canvas
        canvas.width = innerWidth * dpr;
        canvas.height = innerHeight * dpr;

        // Set the "drawn" size of the canvas
        canvas.style.width = `${innerWidth}px`;
        canvas.style.height = `${innerHeight}px`;

        sessionObj.innerWidth = innerWidth;
        sessionObj.innerHeight = innerHeight;
        // Scale the context to ensure correct drawing operations
        ctx.scale(dpr, dpr);

        updateSessionElement(myli, sessionObj);
        drawLines();
        postPosition();
      };

      window.addEventListener("resize", resizeWindow);
      resizeWindow();

      const positionElem = () => {
        if (
          sessionObj.screenLeft === screenLeft &&
          sessionObj.screenTop === screenTop
        ) {
          window.requestAnimationFrame(positionElem);
          return;
        }
        sessionObj.screenLeft = screenLeft;
        sessionObj.screenTop = screenTop;

        drawLines();

        updateSessionElement(myli, sessionObj);
        postPosition();
        window.requestAnimationFrame(positionElem);
      };

      window.requestAnimationFrame(positionElem);

      window.addEventListener("beforeunload", () => {
        channel.postMessage({ sessionId, message: "leaving" });
        channel.close();
      });

      channel.addEventListener("message", ({ data }) => {
        const { sessionId } = data;
        let sessionElement = document.getElementById(sessionId);
        if (data.message === "leaving") {
          sessionMap.delete(sessionId);
          if (sessionElement) sessionElement.remove();
        } else {
          const sess = sessionMap.get(sessionId);
          if (sess) Object.assign(sess, data);
          else {
            // when a new session is created, we broadcast our data
            postPosition();
            sessionMap.set(sessionId, data);
          }
          drawLines();
          if (!sessionElement) {
            sessionElement = createSessionLi(sessionId);
            insertOrdered(sessionElement);
          }
          updateSessionElement(sessionElement, data);
        }
      });
    </script>
  </body>
</html>
